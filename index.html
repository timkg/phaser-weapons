<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sword Dynamics</title>

  <script src="phaser.js"></script>
  <script src="moment-of-inertia/moment-of-inertia.js"></script>
  <script>
    var rotation = {};

    var game = new Phaser.Game(600, 400, Phaser.AUTO, 'gameContainer', {

      preload: function () {
        game.load.image('sword', 'assets/sword.png');
        window.guard = this.guard.bind(this)
      },

      create: function () {
        game.stage.setBackgroundColor('#dedede');
        window.sword = this.sword = game.add.sprite(game.world.centerX, game.world.centerY, 'sword');
        sword.scale.x = 0.5;
        sword.scale.y = 0.5;
        sword.anchor.setTo(0, 0.5); // position defined by handle
        sword.rotation = -Math.PI/2;

        window.left = circle(game.world.centerX - 40, game.world.centerY)
        window.center = circle(game.world.centerX, game.world.centerY)
        window.right = circle(game.world.centerX + 40, game.world.centerY)
      },

      update: function () {
        this.move();
        this.debug(sword)
      },

      move: function () {},

      debug: function (sprite) {
        game.debug.spriteBounds(sprite)
        game.debug.spriteInfo(sprite, 20, 20)
      },

      rotate: function (point) {
        if (rotation._increment && rotation._delta && rotation._delta > 0) {
          point.rotation += rotation._increment;
          point.rotation = Phaser.Math.wrapAngle(point.rotation, true);
          rotation._delta -= Math.abs(rotation._increment)
          return;
        } else {
          rotation = {};
        }
      },

      guard: function (sword, guard) {
        if (Math.abs(guard.x - sword.x) === 0) {
          return;
        }

        var xIncrement;
        var distance =  guard.x - sword.x;
        if (distance > 0) {
          xIncrement = 1
        } else if (distance < 0) {
          xIncrement = -1
        }

        this.move = function () {
          rotateTo(sword, {x: 300, y: 0});
          sword.rotation += rotation._increment;
          sword.x += xIncrement;

          if (Math.abs(guard.x - sword.x) === 0) {
            this.move = function () {}
          }
        }
      }

    });

    function circle (x, y) {
      var g = game.add.graphics(x, y)
      g.lineStyle(0);
      g.beginFill('#ccc', 0.25);
      g.drawCircle(0, -10, 10);
      return g;
    }

    function rotationTo(point, target) {
      var targetAngle = Phaser.Math.angleBetweenPoints(point, target);
      var delta;
      /*
       TODO - figure shortest rotation out, depending on weapon rotation
       rotateTo(sword, {x: 300, y: 0})
       rotateTo(sword, {x: 0, y: 0})
       rotateTo(sword, {x: 0, y: 400})
       if (Math.abs(point.rotation) + Math.abs(targetAngle) > Math.PI / 2) {
       delta = point.rotation + targetAngle
       } else {
       delta = targetAngle - point.rotation;
       }
       */
      delta = targetAngle - point.rotation;
      return delta;
    }

    function rotateTo (point, target, frames) {
      var delta = rotationTo(point, target);
      rotation._delta = Math.abs(delta);
      rotation._increment = delta / (frames || 1);
    }

  </script>
</head>
<body>

<div id="gameContainer"></div>

</body>
</html>